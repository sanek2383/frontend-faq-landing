[
	{
		"question": "Какие примитивные типы данных существуют в JavaScript?",
		"answer": "Примитивы: String, Number, Boolean, Null, Undefined, Symbol, BigInt. Они передаются по значению и являются неизменяемыми (immutable). Любые сложные структуры (объекты, массивы, функции) — ссылочные типы."
	},
	{
		"question": "Что такое объект в JavaScript?",
		"answer": "Объект — это коллекция пар ключ–значение с динамически расширяемым набором свойств. Ключи — строки или Symbol, значения — любого типа. Объекты сравниваются и передаются по ссылке."
	},
	{
		"question": "В чём разница между null и undefined?",
		"answer": "undefined означает «значение отсутствует/не задано» (переменная объявлена, но не инициализирована). null — намеренное отсутствие значения, задаётся явно. Проверяя на равенство, используйте строгое сравнение ===."
	},
	{
		"question": "Что вернёт typeof null и почему?",
		"answer": "typeof null возвращает 'object' из‑за исторической ошибки в спецификации. Это не объект; проверяйте null через строгие сравнения: value === null."
	},
	{
		"question": "Что такое NaN и как его корректно проверять?",
		"answer": "NaN — специальное числовое значение «не число», результат некорректных числовых операций. Проверяйте через Number.isNaN(value); сравнение NaN === NaN всегда ложно."
	},
	{
		"question": "Как проверить, что значение — массив?",
		"answer": "Используйте Array.isArray(value). Это надёжнее, чем instanceof Array, особенно при работе с несколькими реализациями (iframes) или сторонними библиотеками."
	},
	{
		"question": "Как сравниваются объекты в JavaScript?",
		"answer": "Объекты сравниваются по ссылке: два литерала с одинаковым содержимым не равны ({} !== {}). Для сравнения «по значению» пишут глубокие сравнения или используют сериализацию/библиотеки."
	},
	{
		"question": "В чём разница между '==' и '==='?",
		"answer": "== выполняет приведение типов и может приводить к неожиданным результатам ('0' == 0 → true). === сравнивает тип и значение без приведения и считается безопаснее по умолчанию."
	},
	{
		"question": "Для чего нужен оператор typeof?",
		"answer": "typeof возвращает строку с типом значения на момент выполнения (например, 'string', 'object', 'function'). Помните об исключениях: typeof null === 'object'."
	},
	{
		"question": "Что делает оператор instanceof?",
		"answer": "instanceof проверяет наличие конструктора в цепочке прототипов объекта (obj instanceof Ctor). Работает надёжно внутри одного реалма; между реалмами может давать ложные результаты."
	},
	{
		"question": "Что делает оператор in?",
		"answer": "Оператор 'key' in obj проверяет наличие свойства в объекте или его прототипной цепочке. Для проверки «только на самом объекте» используйте Object.hasOwn(obj, key)."
	},
	{
		"question": "Чем отличаются var, let и const?",
		"answer": "var — функциональная область видимости и hoisting с инициализацией undefined; допускает переобъявление. let/const — блочная область видимости и TDZ; const запрещает переназначение ссылки."
	},
	{
		"question": "Что такое hoisting?",
		"answer": "Hoisting — «поднятие» объявлений в начало области видимости. var и функции‑декларации поднимаются; let/const поднимаются логически, но недоступны до инициализации (TDZ)."
	},
	{
		"question": "Что такое область видимости (scope)?",
		"answer": "Scope определяет, где доступны идентификаторы. В JS есть глобальная, функциональная и блочная области. Замыкания позволяют функции удерживать ссылки на внешние переменные."
	},
	{
		"question": "Что такое временная мёртвая зона (TDZ)?",
		"answer": "TDZ — участок кода от начала блока до инициализации let/const, где доступ к переменной вызывает ReferenceError. Это предотвращает обращение к неинициализированным значениям."
	},
	{
		"question": "Что такое замыкание (closure)?",
		"answer": "Замыкание — функция + связанный лексический контекст. Функция помнит внешние переменные даже после завершения внешней функции. Полезно для инкапсуляции и фабрик функций."
	},
	{
		"question": "Что такое IIFE и когда применять?",
		"answer": "IIFE (Immediately Invoked Function Expression) — функция, вызываемая сразу после объявления. Используется для изоляции временных переменных и создания локального скоупа без глобальных утечек."
	},
	{
		"question": "Что такое объект arguments и в чём его отличие от rest‑параметров?",
		"answer": "arguments — псевдомассив с фактически переданными аргументами в обычной функции. Он не работает в стрелочных функциях и лишён большинства методов массива; rest (...) создаёт настоящий массив."
	},
	{
		"question": "Для чего нужны rest‑параметры?",
		"answer": "Rest‑параметры собирают «хвост» аргументов в массив: function f(a, ...rest). Удобны для вариативных функций и работают со стрелочными функциями; заменяют многие случаи использования arguments."
	},
	{
		"question": "Для чего нужен оператор spread?",
		"answer": "Spread (...) разворачивает массив/объект: [...arr], { ...obj }. Применяется для копий, объединений и передачи элементов как отдельных аргументов. Выполняет поверхностное копирование."
	},
	{
		"question": "Что такое стрелочные функции и их особенности?",
		"answer": "Стрелочные функции короче по синтаксису, не имеют собственного this/arguments/super/new.target. Хороши для колбэков; не подходят как конструкторы и методы, где нужен динамический this."
	},
	{
		"question": "Как работает ключевое слово this?",
		"answer": "this определяется контекстом вызова: метод — объект, call/apply/bind — явно заданное значение, конструктор — новый экземпляр. В стрелочных функциях this лексически унаследован."
	},
	{
		"question": "Для чего нужен Function.prototype.bind?",
		"answer": "bind возвращает новую функцию с зафиксированным this и, опционально, частично применёнными аргументами. Используется для передачи методов как колбэков и контроля контекста выполнения."
	},
	{
		"question": "Чем отличаются call и apply?",
		"answer": "Оба вызывают функцию с указанным this. Разница в передаче аргументов: call(a, x, y), apply(a, [x, y]). В современном коде apply часто заменяют на call с spread: fn.call(a, ...args)."
	},
	{
		"question": "Что такое прототипное наследование?",
		"answer": "Объекты делят поведение через цепочку __proto__/[[Prototype]]. Поиск свойства идёт по цепочке до Object.prototype. Это основа классового синтаксиса и работы instanceof."
	},
	{
		"question": "Для чего используется Object.create?",
		"answer": "Object.create(proto, descriptors?) создаёт объект с заданным прототипом. Удобно для «чистых» словарей (Object.create(null)) и для тонкого контроля над свойствами/наследованием."
	},
	{
		"question": "Что такое классы в ES6 и как они связаны с прототипами?",
		"answer": "Классы — синтаксический сахар над прототипами: методы лежат на prototype, наследование оформляется через extends/super. Поля/статические члены/приватные #поля — дополнительные возможности."
	},
	{
		"question": "Чем отличаются function declaration и function expression?",
		"answer": "Declaration поднимается целиком (можно вызывать до объявления). Expression создаёт функцию как значение, не поднимается целиком. Выбор влияет на порядок кода и тестируемость."
	},
	{
		"question": "Что такое JSON и где его применять?",
		"answer": "JSON — текстовый формат обмена данными, близкий к синтаксису объектов JS. Используется в REST, настройках и хранилищах. Не поддерживает функции, undefined и ссылки по умолчанию."
	},
	{
		"question": "Что делает JSON.stringify и какие есть опции?",
		"answer": "Преобразует значение в строку JSON. Второй аргумент — replacer (фильтрация/трансформация), третий — отступы/форматирование. Кольцевые ссылки вызовут ошибку без кастомной обработки."
	},
	{
		"question": "Что делает JSON.parse и как безопасно парсить?",
		"answer": "Преобразует JSON‑строку в значение. Второй аргумент — reviver для пост‑обработки (например, восстановление дат). Парсьте только доверенные строки или валидируйте формат заранее."
	},
	{
		"question": "Как работает setTimeout и точность таймеров?",
		"answer": "setTimeout планирует колбэк после минимальной задержки; реальное время зависит от нагрузок и очередей. Минимальная задержка в неактивных вкладках/таймерах может быть повышена браузером."
	},
	{
		"question": "Для чего нужен setInterval и почему его часто избегают?",
		"answer": "setInterval вызывает колбэк периодически. При долгих задачах колбэки могут «скапливаться»; чаще используют рекурсивный setTimeout или requestAnimationFrame для предсказуемости."
	},
	{
		"question": "Как отменить таймеры?",
		"answer": "clearTimeout(id) и clearInterval(id) отменяют соответствующие таймеры. Всегда сохраняйте id, особенно в компонентах UI, чтобы убирать эффекты при размонтировании."
	},
	{
		"question": "Что такое callback‑функция и как избегать callback hell?",
		"answer": "Callback — функция, передаваемая как аргумент и вызываемая при наступлении события/результата. Для сложной асинхронщины используйте промисы/async‑await и композицию вместо вложенности."
	},
	{
		"question": "Что такое Promise и его основные состояния?",
		"answer": "Promise инкапсулирует асинхронное вычисление со состояниями pending → fulfilled/rejected. Цепочки then/catch формируют пайплайны; один промис резолвится/реджектится только один раз."
	},
	{
		"question": "Как работает Promise.prototype.then и чейнинг?",
		"answer": "then принимает обработчик успеха и возвращает новый промис, позволяя строить цепочки. Возвращённое значение/промис определяет, что попадёт дальше по цепочке."
	},
	{
		"question": "Для чего нужен Promise.prototype.catch?",
		"answer": "catch перехватывает ошибки в предыдущих шагах цепочки (включая синхронные исключения). Можно ставить в конце цепочки как общий обработчик."
	},
	{
		"question": "Для чего нужен Promise.prototype.finally?",
		"answer": "finally вызывает колбэк при любом исходе без изменения значения/ошибки. Удобен для освобождения ресурсов, скрытия лоадеров и завершения побочных эффектов."
	},
	{
		"question": "Что такое async/await и как обрабатывать ошибки?",
		"answer": "async функция возвращает промис; await «распаковывает» его результат. Ошибки ловят через try/catch или Promise.allSettled; параллелизм достигается запуском промисов до await."
	},
	{
		"question": "Как работает event loop в браузере/Node.js?",
		"answer": "Event loop обрабатывает очереди задач: макрозадачи (timers, I/O) и микрозадачи (промисы). После каждой макрозадачи выполняются все микрозадачи, затем перерисовка/следующая итерация."
	},
	{
		"question": "Что такое microtask queue и что туда попадает?",
		"answer": "Очередь микрозадач содержит then/catch/finally, MutationObserver и process.nextTick (в Node.js приоритетнее). Микрозадачи выполняются до следующей перерисовки/макрозадачи."
	},
	{
		"question": "Что такое macrotask queue и примеры?",
		"answer": "Макрозадачи — более «крупные» события: setTimeout, setInterval, I/O, messageChannel, UI‑события. Между макрозадачами движок может делать рендер кадра."
	},
	{
		"question": "Что такое всплытие событий (bubbling)?",
		"answer": "Событие идёт от целевого элемента вверх по дереву к document, вызывая обработчики по пути. Это позволяет ставить обработчики на контейнеры и реагировать централизованно."
	},
	{
		"question": "Что такое погружение (capturing) и порядок фаз?",
		"answer": "Capturing проходит сверху вниз, затем target, затем bubbling. addEventListener(type, handler, { capture: true }) слушает на фазе погружения; по умолчанию — на фазе всплытия."
	},
	{
		"question": "Как остановить всплытие и предотвратить действие по умолчанию?",
		"answer": "event.stopPropagation()/stopImmediatePropagation() останавливают распространение. event.preventDefault() отменяет стандартное действие (например, отправку формы/переход по ссылке)."
	},
	{
		"question": "Что такое делегирование событий и зачем оно нужно?",
		"answer": "Ставим один обработчик на родителя и различаем цели через event.target/closest(). Это экономит память, упрощает работу с динамическими списками и снижает количество подписок."
	},
	{
		"question": "Для чего используется Array.prototype.map?",
		"answer": "map создаёт новый массив, применяя функцию к каждому элементу (чистая трансформация). Не изменяет исходный массив; удобен для преобразования данных в UI‑модели."
	},
	{
		"question": "Для чего используется Array.prototype.filter?",
		"answer": "filter возвращает новый массив, оставляя элементы, для которых предикат true. Полезен для фильтрации по условиям без мутаций; производительность зависит от размера массива/предиката."
	},
	{
		"question": "Для чего используется Array.prototype.reduce?",
		"answer": "reduce сворачивает массив в одно значение (сумма, объект, Map). Начальное значение важно для пустых массивов; избегайте сложной логики — выносите в отдельные функции."
	},
	{
		"question": "В чём особенность Array.prototype.forEach?",
		"answer": "forEach перебирает элементы ради побочных эффектов (логирование, мутации). Не возвращает новый массив и игнорирует break/return из колбэка — используйте some/every для раннего выхода."
	},
	{
		"question": "Для чего используется Array.prototype.find?",
		"answer": "find возвращает первый элемент, удовлетворяющий предикату, или undefined. Для индекса используйте findIndex; для поиска справа — findLast/findLastIndex (если доступны)."
	},
	{
		"question": "Когда использовать Array.prototype.some и every?",
		"answer": "some проверяет, есть ли хотя бы один элемент, удовлетворяющий условию (короткое замыкание). every — все ли элементы соответствуют. Оба могут ускорить проверки больших массивов."
	},
	{
		"question": "Для чего используется Array.prototype.includes?",
		"answer": "includes проверяет наличие значения в массиве (NaN поддерживается). В отличие от indexOf не требует сравнивать с −1; полезен для простых проверок принадлежности."
	},
	{
		"question": "Что делает Object.freeze и какие ограничения?",
		"answer": "freeze делает объект неизменяемым: нельзя добавлять/удалять/менять свойства. Это поверхностно: вложенные объекты остаются изменяемыми без дополнительной глубокой заморозки."
	},
	{
		"question": "Чем отличаются Object.seal и Object.preventExtensions?",
		"answer": "seal запрещает добавление/удаление свойств, но позволяет менять существующие (если writable: true). preventExtensions только запрещает добавление новых свойств."
	},
	{
		"question": "Для чего нужны Object.keys/values/entries?",
		"answer": "keys возвращает массив собственных перечислимых ключей, values — значений, entries — пар [ключ, значение]. Удобно для итерации и преобразований через map/reduce."
	},
	{
		"question": "Что делает Object.fromEntries и когда полезно?",
		"answer": "fromEntries строит объект из пар [ключ, значение]. Полезно при инвертировании структур, работе с Map и после трансформаций массива entries()."
	},
	{
		"question": "Что такое Symbol и где применить?",
		"answer": "Symbol — уникальный идентификатор, часто для закрытых/служебных ключей свойств. Не участвует в обычной итерации по ключам; есть глобальный реестр Symbol.for."
	},
	{
		"question": "Что такое итераторы и протокол итерации?",
		"answer": "Итератор — объект с методом next(), возвращающим { value, done }. Объекты итерируемы, если имеют Symbol.iterator; это позволяет использовать for...of и spread."
	},
	{
		"question": "Что такое генераторы и когда их использовать?",
		"answer": "Генераторы (function*) позволяют ленивую выдачу значений через yield и двустороннюю коммуникацию через next()/throw(). Полезны для ленивых коллекций и сложных итераций."
	},
	{
		"question": "Что такое async‑генераторы и for‑await‑of?",
		"answer": "Async function* выдаёт промисы значений, потребляются через for‑await‑of. Удобны для потоковой обработки I/O и последовательных асинхронных источников данных."
	},
	{
		"question": "Что такое WeakMap и зачем она нужна?",
		"answer": "WeakMap хранит пары ключ‑значение, где ключи — только объекты и учитываются сборщиком мусора. Полезно для приватных данных и кэшей без предотвращения GC."
	},
	{
		"question": "Что такое WeakSet и чем отличается от Set?",
		"answer": "WeakSet хранит только объекты и не препятствует их сборке мусора; нет размера и итерации. Подходит для пометок «видел/не видел» без утечек памяти."
	},
	{
		"question": "Чем Map отличается от обычного объекта?",
		"answer": "Map принимает ключи любого типа и сохраняет порядок вставки; размер через size, удобная итерация. Объекты лучше для структур с фиксированными строковыми ключами/JSON."
	},
	{
		"question": "Что такое Set и когда применять?",
		"answer": "Set — коллекция уникальных значений. Удобен для удаления дублей, проверок принадлежности и операций над множествами (объединение/пересечение) без O(n) поиска."
	},
	{
		"question": "Что такое Proxy и типичные ловушки (traps)?",
		"answer": "Proxy перехватывает операции с целевым объектом (get, set, has, ownKeys, apply, construct и др.). Применяется для валидации, реактивности, виртуализации и логирования."
	},
	{
		"question": "Для чего нужен объект Reflect?",
		"answer": "Reflect содержит методы, соответствующие внутренним операциям (Reflect.get, set, apply и т.д.), и возвращает булевы/значения вместо исключений. Удобен внутри прокси‑ловушек."
	},
	{
		"question": "Что такое мемоизация и когда она полезна?",
		"answer": "Мемоизация кэширует результаты детерминированных функций по аргументам, снижая повторные вычисления. Эффективна для тяжёлых/чистых функций; следите за размером кэша и ключами."
	},
	{
		"question": "Что такое хвостовая рекурсия и поддерживается ли TCO?",
		"answer": "Хвостовой вызов — рекурсия в позиции return, позволяющая теоретически оптимизировать стек (TCO). В большинстве движков JS TCO не реализована; используйте циклы/итерации."
	},
	{
		"question": "Что такое каррирование и чем полезно?",
		"answer": "Каррирование превращает f(a,b,c) в f(a)(b)(c), позволяя частично применять аргументы и строить композиции. Улучшает переиспользование и читаемость в функциональном стиле."
	},
	{
		"question": "Что такое частичное применение?",
		"answer": "Частичное применение фиксирует часть аргументов функции и возвращает новую. Отличается от каррирования тем, что не требует по одному аргументу на шаг."
	},
	{
		"question": "Что такое модульный паттерн (Module Pattern)?",
		"answer": "Паттерн использует IIFE/замыкания для инкапсуляции приватных переменных и экспорта публичного API. Исторически применялся до ES‑модулей; полезен для локальных состояний."
	},
	{
		"question": "Что такое паттерн Singleton и когда его избегать?",
		"answer": "Singleton гарантирует единственный экземпляр. В JS часто реализуется через модуль/замыкание. Может усложнять тестирование и увеличивать связность — применяйте осмотрительно."
	},
	{
		"question": "Что такое паттерн Observer в контексте JS?",
		"answer": "Observer — субъект оповещает наблюдателей о событиях (EventEmitter, DOM‑события). Хорош для реактивности и плагинов; следите за отпиской, чтобы избежать утечек."
	},
	{
		"question": "Что такое паттерн Фабрика (Factory)?",
		"answer": "Фабрика создаёт объекты определённого типа, скрывая детали конструирования. Удобна для выбора реализаций по параметрам/окружению, в тестах — для подмен."
	},
	{
		"question": "Что такое движок V8 и из чего он состоит?",
		"answer": "V8 — движок JS (Chrome/Node.js) с парсером, оптимизирующим компилятором и сборщиком мусора. JIT превращает часто исполняемый код в машинный для скорости."
	},
	{
		"question": "Что такое JIT‑компиляция в JS‑движках?",
		"answer": "Just‑In‑Time компиляторы анализируют горячие участки и специализируют код под наблюдаемые типы. Деградация возможна при мегаморфных вызовах и частых сменах типов."
	},
	{
		"question": "Как работает сборка мусора в JS?",
		"answer": "GC освобождает память объектов, на которые нет достижимых ссылок (алгоритмы: маркировка‑сжатие, поколенческие). Избегайте невидимых ссылок (кэши, замыкания) — это утечки."
	},
	{
		"question": "Что такое слабые ссылки и FinalizationRegistry?",
		"answer": "WeakRef/FinalizationRegistry позволяют ссылаться на объекты, не препятствуя GC, и реагировать на их освобождение. Применяйте аккуратно — семантика недетерминирована."
	},
	{
		"question": "Что такое AST и где оно применяется?",
		"answer": "Абстрактное синтаксическое дерево представляют парсеры (Acorn/Esprima). Используется в линтерах, трансформерах (Babel), минификациях и статическом анализе."
	},
	{
		"question": "Что такое ShadowRealm?",
		"answer": "Предлагаемая изолированная среда выполнения JS без доступа к глобальному объекту вызывающей стороны. Подходит для безопасной оценки кода; поддержка зависит от среды/стандарта."
	},
	{
		"question": "Что такое SharedArrayBuffer и ограничения безопасности?",
		"answer": "SharedArrayBuffer даёт общий участок памяти между потоками (workers). Для включения в браузерах требуется изоляция сайта (COOP/COEP) из‑за уязвимостей по времени (Spectre)."
	},
	{
		"question": "Для чего нужен объект Atomics?",
		"answer": "Atomics предоставляет атомарные операции и ожидание/уведомление (wait/notify) на SharedArrayBuffer. Это основа примитивов синхронизации между воркерами."
	},
	{
		"question": "Что такое Web Workers и когда их использовать?",
		"answer": "Workers выполняют JS в фоновом потоке, не блокируя UI. Подходят для тяжёлых вычислений/парсинга; общение через postMessage/структурированное клонирование/SharedArrayBuffer."
	},
	{
		"question": "Что такое Service Workers и возможности PWA?",
		"answer": "Service Worker — прокси‑слой между приложением и сетью для кэша, офлайна и пушей. Работает по HTTPS, имеет жизненный цикл (install/activate) и гибкие стратегии кэширования."
	},
	{
		"question": "Что такое IndexedDB и когда выбирать её?",
		"answer": "IndexedDB — асинхронное ключ‑значение хранилище в браузере с индексами и транзакциями. Выбирайте для больших объёмов/офлайна; для простых кейсов хватит localStorage."
	},
	{
		"question": "Что такое WebAssembly и как оно сочетается с JS?",
		"answer": "WebAssembly — бинарный формат, выполняемый с почти нативной скоростью. Используется для тяжёлых задач (обработка медиа, вычисления) и взаимодействует с JS через импорт/экспорт."
	},
	{
		"question": "Почему делегирование событий улучшает производительность списков?",
		"answer": "Один обработчик на контейнер вместо тысячи на элементах снижает потребление памяти и затраты на подписки/отписки. Особенно эффективно при динамическом DOM (виртуальные списки)."
	},
	{
		"question": "Что такое debounce и когда его применять?",
		"answer": "Debounce откладывает выполнение функции, пока события продолжают приходить (поиск по вводу, ресайз). Снижает лишние вызовы; следите за вызовом по leading/trailing краям."
	},
	{
		"question": "Что такое throttle и чем он отличается от debounce?",
		"answer": "Throttle ограничивает частоту вызовов (не чаще X мс) — полезно для скролла/ресайза. В отличие от debounce, он гарантирует регулярные вызовы в течение активности."
	},
	{
		"question": "Что такое polyfill и чем он отличается от шимов?",
		"answer": "Polyfill добавляет недостающую функциональность стандарта (например, Promise). Шим может менять поведение существующих API. Подбирайте таргеты под окружения (browserslist)."
	},
	{
		"question": "Что такое транспилятор (например, Babel)?",
		"answer": "Транспилятор преобразует код на современном JS/TS в совместимый с целевыми окружениями. Поддерживает плагины/пресеты и часто интегрируется с source maps для отладки."
	},
	{
		"question": "Что такое tree‑shaking и условия для его работы?",
		"answer": "Tree‑shaking удаляет неиспользуемый код на этапе сборки. Требует ESM (статический импорт/экспорт) и информации о сайд‑эффектах; динамические require мешают оптимизации."
	},
	{
		"question": "Что такое поле sideEffects в package.json?",
		"answer": "Поле sideEffects подсказывает сборщику, какие файлы безопасно удалять при tree‑shaking. 'false' означает отсутствие побочных эффектов при импорте модулей (кроме явно указанных)."
	},
	{
		"question": "В чём разница между ESM и CommonJS?",
		"answer": "ESM — статические импорты/экспорты, поддерживает tree‑shaking, топ‑левел await; CommonJS — динамический require, module.exports, синхронная загрузка. Совместимость требует бриджей."
	},
	{
		"question": "Что такое top‑level await и где доступен?",
		"answer": "Top‑level await позволяет использовать await в корне ESM‑модуля. Упрощает инициализацию модулей, но делает импорт модуля асинхронным; недоступен в CommonJS."
	}
]
