[
	{
		"question": "Что такое React и для чего он используется?",
		"answer": "React — это библиотека для построения пользовательских интерфейсов, разработанная Facebook. Она позволяет создавать декларативные, компонентно-ориентированные приложения с эффективным обновлением DOM через виртуальный DOM. Используется для SPA, SSR, мобильных приложений (React Native) и сложных UI-систем."
	},
	{
		"question": "Что такое JSX и зачем он нужен?",
		"answer": "JSX — это синтаксическое расширение JavaScript, позволяющее писать HTML-подобную разметку внутри JS-кода. Он компилируется в вызовы React.createElement(). JSX делает код более читаемым, декларативным и позволяет легко встраивать выражения через {expression}."
	},
	{
		"question": "Что такое компонент в React?",
		"answer": "Компонент — это переиспользуемый блок UI, который может быть функцией (функциональный компонент) или классом (классовый компонент). Принимает props, может управлять состоянием и возвращать JSX. Компоненты позволяют разбивать интерфейс на независимые части."
	},
	{
		"question": "Что такое props?",
		"answer": "Props (свойства) — это входные данные, передаваемые компоненту от родителя. Они неизменны внутри компонента и используются для конфигурации и передачи данных. Пример: <Button label='Отправить' disabled={true} />."
	},
	{
		"question": "Что такое state?",
		"answer": "State — это внутреннее состояние компонента, которое может изменяться во времени. При его изменении React перерисовывает компонент. В функциональных компонентах используется через хук useState: const [count, setCount] = useState(0)."
	},
	{
		"question": "В чём разница между props и state?",
		"answer": "Props передаются извне и неизменны внутри компонента (immutable), state управляется самим компонентом и изменяется (mutable). Props — для конфигурации, state — для динамических данных, влияющих на UI."
	},
	{
		"question": "Что такое жизненный цикл компонента?",
		"answer": "Жизненный цикл — это последовательность этапов: монтирование, обновление и размонтирование. В классовых компонентах используются методы: componentDidMount, componentDidUpdate, componentWillUnmount. В функциональных — хук useEffect."
	},
	{
		"question": "Что такое useState и как его использовать?",
		"answer": "useState — хук для управления состоянием в функциональных компонентах. Возвращает массив: [значение, функция-сеттер]. При вызове сеттера React запланирует перерисовку. Поддерживает функциональные обновления: setCount(prev => prev + 1)."
	},
	{
		"question": "Что такое useEffect и как его использовать?",
		"answer": "useEffect — хук для побочных эффектов: запросы к API, подписки, таймеры. Выполняется после рендера. Принимает функцию и опциональный массив зависимостей. Пустой массив [] означает выполнение один раз при монтировании. Возвращаемая функция — очистка (аналог componentWillUnmount)."
	},
	{
		"question": "Что такое useContext и когда применять?",
		"answer": "useContext позволяет получать значение из React Context без передачи props через промежуточные компоненты. Используется для глобальных данных: тема, язык, аутентификация. Пример: const theme = useContext(ThemeContext)."
	},
	{
		"question": "Что такое useReducer и зачем нужен?",
		"answer": "useReducer — альтернатива useState для сложного состояния. Принимает редьюсер (state, action) => newState и начальное состояние. Полезен при множестве связанных полей или сложной логике. Часто используется с useContext для глобального стейт-менеджмента."
	},
	{
		"question": "Что такое React.memo и как использовать?",
		"answer": "React.memo — HOC, который предотвращает повторный рендер функционального компонента, если его props не изменились. По умолчанию сравнивает props поверхностно. Можно передать кастомную функцию сравнения. Используется для оптимизации производительности."
	},
	{
		"question": "Что такое useCallback?",
		"answer": "useCallback возвращает мемоизированную версию функции и сохраняет её ссылку между рендерами. Полезно при передаче колбэков в оптимизированные дочерние компоненты (через React.memo), чтобы избежать лишних ререндеров."
	},
	{
		"question": "Что такое useMemo?",
		"answer": "useMemo мемоизирует результат вычислений и пересчитывает его только при изменении зависимостей. Используется для оптимизации дорогих вычислений (сортировка, фильтрация, математика). Не используй для простых операций — это может ухудшить производительность."
	},
	{
		"question": "Что такое useRef и как применяется?",
		"answer": "useRef возвращает изменяемый объект с полем .current, который сохраняет значение между рендерами. Не вызывает ререндер при изменении. Используется для: доступа к DOM-элементам, хранения mutable-значений (например, таймеров), кэширования без триггера обновлений."
	},
	{
		"question": "Что такое React.lazy и Suspense?",
		"answer": "React.lazy позволяет лениво загружать компонент (code splitting). Suspense определяет fallback-UI во время загрузки. Пример: const LazyComponent = React.lazy(() => import('./Component')); <Suspense fallback={<Spinner />}><LazyComponent /></Suspense>."
	},
	{
		"question": "Что такое Error Boundary?",
		"answer": "Error Boundary — классовый компонент с методом componentDidCatch, который перехватывает ошибки в дочерних компонентах во время рендера. Позволяет показать запасной UI и не допустить падения всего приложения. Не ловит ошибки в обработчиках событий или асинхронных колбэках."
	},
	{
		"question": "Что такое Portals?",
		"answer": "Portals позволяют рендерить дочерние элементы в DOM-узел, находящийся вне иерархии родительского компонента. Используется для модальных окон, всплывающих подсказок, меню. Реализуется через ReactDOM.createPortal(child, domNode)."
	},
	{
		"question": "Что такое Fragment и зачем использовать?",
		"answer": "Fragment (<React.Fragment> или <>...</>) позволяет группировать несколько элементов без добавления лишнего DOM-узла. Полезно, когда нельзя обернуть в div (например, внутри <table> или для соблюдения семантики)."
	},
	{
		"question": "Что такое Controlled и Uncontrolled компоненты?",
		"answer": "Controlled компоненты управляются через state и onChange. Значение контролируется React. Uncontrolled — управляются DOM, значение получается через ref. Пример Controlled: <input value={value} onChange={handleChange} />. Uncontrolled: <input ref={inputRef} defaultValue='...' />."
	},
	{
		"question": "Что такое useNavigate?",
		"answer": "useNavigate — хук из React Router v6+, позволяющий программно управлять навигацией. Возвращает функцию navigate(to, options). Поддерживает: замену маршрута (replace: true), передачу состояния (state), навигацию на n шагов (navigate(-1))."
	},
	{
		"question": "Что такое useParams?",
		"answer": "useParams — хук React Router, возвращающий объект с параметрами из URL. Например, для маршрута /users/:id вызов useParams() вернёт { id: '123' }. Используется для получения динамических сегментов пути."
	},
	{
		"question": "Что такое useLocation?",
		"answer": "useLocation возвращает объект location с текущим URL, pathname, search, hash и state. Позволяет реагировать на изменения маршрута. Часто используется для анализа query-параметров или отслеживания переходов."
	},
	{
		"question": "Что такое useRoutes?",
		"answer": "useRoutes — хук, позволяющий определять маршруты в виде массива объектов. Возвращает элемент для рендера на основе текущего URL. Альтернатива <Route> в JSX. Полезно для динамических маршрутов и централизованной конфигурации."
	},
	{
		"question": "Что такое useOutlet?",
		"answer": "useOutlet возвращает элемент дочернего маршрута в иерархии вложенных роутов. Используется в layout-компонентах для рендеринга контента дочерних страниц. Аналог <Outlet /> в виде хука."
	},
	{
		"question": "Что такое useMatch?",
		"answer": "useMatch проверяет, соответствует ли текущий URL заданному шаблону. Возвращает объект сопоставления или null. Полезно для условного рендеринга (например, подсветки активного пункта меню)."
	},
	{
		"question": "Что такое useImperativeHandle?",
		"answer": "useImperativeHandle позволяет настроить публичный API компонента, доступный через ref. Используется с forwardRef. Пример: expose только метод focus(), скрывая внутренние детали. Полезно для создания императивных интерфейсов."
	},
	{
		"question": "Что такое useLayoutEffect и чем отличается от useEffect?",
		"answer": "useLayoutEffect вызывается синхронно после всех изменений DOM, но до отрисовки браузером. useEffect — асинхронно. useLayoutEffect полезен для измерений (offsetHeight) и синхронных изменений стилей, чтобы избежать мерцания."
	},
	{
		"question": "Что такое useDebugValue?",
		"answer": "useDebugValue позволяет отображать метку в React DevTools для пользовательских хуков. Улучшает отладку. Пример: useDebugValue(isOpen ? 'Open' : 'Closed'). Не влияет на производительность в продакшене."
	},
	{
		"question": "Что такое Context и как его применять?",
		"answer": "Context позволяет передавать данные через дерево компонентов без явной передачи props. Создаётся через React.createContext(defaultValue). Provider задаёт значение, useContext — получает. Используй умеренно — не заменяй им всё состояние."
	},
	{
		"question": "Что такое Higher-Order Component (HOC)?",
		"answer": "HOC — функция, принимающая компонент и возвращающая новый компонент с дополнительной логикой. Пример: withAuth, withLogging. Позволяет повторно использовать поведение. Альтернатива — пользовательские хуки."
	},
	{
		"question": "Что такое Render Props?",
		"answer": "Render Props — паттерн, при котором компонент принимает функцию, возвращающую JSX. Позволяет делиться логикой между компонентами. Пример: <Mouse render={(x, y) => <Cat x={x} y={y} />} />. Альтернатива — хуки."
	},
	{
		"question": "Что такое StrictMode и зачем он нужен?",
		"answer": "StrictMode — компонент, включающий дополнительные проверки в режиме разработки: дублирование рендеров, использование устаревших API, побочные эффекты. Не влияет на продакшен. В React 18 дополнительно проверяет чистоту эффектов."
	},
	{
		"question": "Что такое ключи (keys) в списках и зачем они нужны?",
		"answer": "Keys помогают React идентифицировать, какие элементы были добавлены, изменены или удалены. Должны быть уникальными и стабильными (лучше — ID, а не индекс). Позволяют эффективно обновлять DOM и сохранять состояние компонентов."
	},
	{
		"question": "Что такое lazy loading и как его реализовать в React?",
		"answer": "Lazy loading — отложенная загрузка компонентов. Реализуется через React.lazy и Suspense. Уменьшает размер начального бандла. Поддерживается сборщиками (Webpack, Vite). Идеально для роутов и тяжёлых компонентов."
	},
	{
		"question": "Что такое Reconciliation?",
		"answer": "Reconciliation — процесс сравнения нового виртуального DOM с предыдущим для определения минимальных изменений в реальном DOM. React использует эвристики (например, по ключам) для эффективного обновления. Основа производительности React."
	},
	{
		"question": "Что такое forwardRef и когда применять?",
		"answer": "forwardRef позволяет передавать ref из родителя в дочерний компонент, особенно когда дочерний — функциональный. Используется с useImperativeHandle для императивного доступа. Пример: CustomInput = forwardRef((props, ref) => <input ref={ref} />)."
	},
	{
		"question": "Что такое useId и для чего он нужен?",
		"answer": "useId генерирует уникальный, стабильный ID, безопасный для SSR. Используется для связывания label с input, aria-атрибутов, fragment-ключей. Пример: const id = useId(); <label htmlFor={id}>Name</label><input id={id} />."
	},
	{
		"question": "Что такое lazy initialization в useState?",
		"answer": "Lazy initialization позволяет вычислить начальное состояние только один раз при монтировании. Передаётся функция: useState(() => computeExpensiveValue()). Полезно для тяжёлых вычислений или получения значения из localStorage."
	},
	{
		"question": "Что такое React Profiler и как его использовать?",
		"answer": "Profiler — компонент для измерения производительности. Замеряет время рендера и количество обновлений. Принимает onRender-колбэк. Пример: <Profiler id='Sidebar' onRender={(id, phase, duration) => log(id, duration)}>. Используется в dev-режиме."
	},
	{
		"question": "Что такое Concurrent Mode и какие возможности он даёт?",
		"answer": "Concurrent Mode — набор функций для более отзывчивого UI. Позволяет приоритизировать обновления, прерывать рендер, откладывать низкоприоритетные задачи. Включает useTransition, useDeferredValue, Suspense для данных. Доступен с React 18."
	},
	{
		"question": "Что такое useTransition и как улучшает UX?",
		"answer": "useTransition позволяет пометить обновления как низкоприоритетные. Пока React обрабатывает срочные действия (ввод), менее важные (фильтрация) откладываются. Пример: startTransition(() => setSearch(q)). Улучшает восприятие производительности."
	},
	{
		"question": "Что такое useDeferredValue и чем отличается от useTransition?",
		"answer": "useDeferredValue откладывает обновление значения на один рендер, если UI заблокирован. Используется для оптимизации рендеров. useTransition — для управления приоритетом обновлений. useDeferredValue проще в использовании, но менее гибкий."
	},
	{
		"question": "Что такое Server Components и как они работают?",
		"answer": "Server Components — компоненты, которые рендерятся на сервере и не отправляются в бандл. Позволяют использовать серверные ресурсы (БД, файлы) напрямую. Работают в Next.js App Router. Снижают размер бандла, ускоряют загрузку, упрощают логику."
	},
	{
		"question": "Что такое React Server Components и чем они отличаются от SSR?",
		"answer": "SSR — рендеринг на сервере, но весь JS всё равно уходит клиенту. Server Components — часть компонентов остаётся на сервере, не генерирует JS. Это не просто рендеринг, а разделение логики: сервер — данные, клиент — интерактивность."
	},
	{
		"question": "Что такое hydration и как работает в React?",
		"answer": "Hydration — процесс, при котором React «оживляет» статический HTML, добавляя обработчики событий и делая его интерактивным. В React 18 улучшен: потоковая гидрация (можно рендерить по частям) и частичная гидрация (не всё дерево сразу)."
	},
	{
		"question": "Что такое Strict Mode в React 18 и что он делает?",
		"answer": "В React 18 Strict Mode дополнительно монтирует и размонтирует компоненты дважды (в dev), чтобы выявить побочные эффекты. Это помогает писать чистые компоненты и готовиться к будущим возможностям (например, Offscreen API)."
	},
	{
		"question": "Что такое batching и как изменилось в React 18?",
		"answer": "Batching — объединение нескольких обновлений state в один ререндер. В React 18 batching работает и в асинхронных колбэках (setTimeout, fetch), а не только в обработчиках событий. Это улучшает производительность без изменений кода."
	},
	{
		"question": "Что такое flushSync и когда его использовать?",
		"answer": "flushSync принудительно синхронно обновляет DOM. Используется редко — когда нужно срочно прочитать DOM после обновления state. Пример: flushSync(() => setCount(c => c + 1)); console.log(document.getElementById('count').textContent);"
	},
	{
		"question": "Как работает React с событиями (синтетические события)?",
		"answer": "React использует синтетические события — кросс-браузерная обёртка над нативными. Все обработчики вешаются на корневой контейнер (в React 17+), а не на document. Это улучшает инкапсуляцию и позволяет работать с порталами."
	},
	{
		"question": "Что такое useMemo и когда НЕ нужно его использовать?",
		"answer": "useMemo не всегда нужен. Не используй его для простых вычислений — это лишняя нагрузка. Также не используй для оптимизации ререндеров дочерних компонентов — для этого нужен React.memo. useMemo — только для тяжёлых вычислений."
	},
	{
		"question": "Что такое React DevTools и какие возможности они дают?",
		"answer": "React DevTools — расширение для отладки. Позволяет просматривать дерево компонентов, props, state, хуки, профилировать рендеры, проверять ререндеры. Критически важен для диагностики производительности и поиска утечек."
	},
	{
		"question": "Что такое ключи (keys) и почему нельзя использовать индекс массива?",
		"answer": "Keys помогают React определить, какие элементы изменились. Использование индекса как key плохо при вставке/удалении — React будет перерисовывать всё, а не переиспользовать компоненты. Лучше использовать уникальный ID, стабильный между рендерами."
	},
	{
		"question": "Что такое custom hooks и как их создавать?",
		"answer": "Custom hook — функция, начинающаяся с 'use', которая использует другие хуки. Позволяет выносить логику в переиспользуемые модули. Пример: useLocalStorage, useFetch. Нельзя вызывать хуки внутри условий или циклов — только на верхнем уровне."
	},
	{
		"question": "Что такое suspense для данных (experimental)?",
		"answer": "Suspense для данных — возможность приостанавливать рендер компонента, пока не загрузятся данные. Позволяет показывать fallback (например, спиннер) во время загрузки. Пока experimental, но используется в Relay и Next.js."
	},
	{
		"question": "Что такое Offscreen API (планируется)?",
		"answer": "Offscreen API — будущая возможность React для скрытия, сохранения состояния и приоритизации компонентов, которые не видны (например, вкладки, модалки). Позволит улучшить производительность за счёт приостановки рендеров."
	}
]
