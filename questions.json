{
  "JS": [
    {
      "question": "Какие типы данных существуют в JavaScript?",
      "answer": "Примитивные типы: String, Number, Boolean, Null, Undefined, Symbol, BigInt. Объекты: Object, Array, Function и другие."
    },
    {
      "question": "В чём разница между '==' и '==='?",
      "answer": "'==' сравнивает значения с приведением типов, а '===' сравнивает и типы, и значения без приведения."
    },
    {
      "question": "Что такое замыкание (closure)?",
      "answer": "Замыкание — это функция, которая сохраняет доступ к переменным из своей внешней области видимости даже после завершения выполнения внешней функции."
    },
    {
      "question": "Что такое hoisting?",
      "answer": "Hoisting — это механизм, при котором объявления переменных и функций поднимаются в верх своей области видимости перед выполнением кода."
    },
    {
      "question": "Чем отличаются var, let и const?",
      "answer": "var — функциональная область видимости, допускает переобъявление; let и const — блочная область видимости, const нельзя переопределить."
    },
    {
      "question": "Что такое IIFE?",
      "answer": "IIFE (Immediately Invoked Function Expression) — это функция, которая вызывается сразу после определения."
    },
    {
      "question": "Что такое прототипное наследование?",
      "answer": "Это механизм, при котором объекты могут наследовать свойства и методы от других объектов через цепочку прототипов."
    },
    {
      "question": "Как работает оператор 'this'?",
      "answer": "Значение 'this' зависит от контекста вызова функции и может быть определено во время выполнения."
    },
    {
      "question": "Что такое стрелочные функции?",
      "answer": "Стрелочные функции — это сокращённый синтаксис для объявления функций, которые не имеют собственного 'this'."
    },
    {
      "question": "Что такое промисы (Promises)?",
      "answer": "Промисы — это объекты, представляющие результат асинхронной операции, которые могут быть в состоянии ожидания, выполнены или отклонены."
    },
    {
      "question": "Как работает async/await?",
      "answer": "async/await — это синтаксический сахар для работы с промисами, позволяющий писать асинхронный код в синхронном стиле."
    },
    {
      "question": "Что такое event loop?",
      "answer": "Event loop — это механизм, который позволяет JavaScript выполнять неблокирующие операции, обрабатывая события и колбэки в очереди."
    },
    {
      "question": "Что такое всплытие событий (event bubbling)?",
      "answer": "Это процесс, при котором событие сначала обрабатывается на самом глубоком элементе, а затем поднимается вверх по дереву DOM."
    },
    {
      "question": "Как предотвратить всплытие события?",
      "answer": "Используя метод event.stopPropagation() в обработчике события."
    },
    {
      "question": "Что такое делегирование событий?",
      "answer": "Это практика добавления одного обработчика события к родительскому элементу для управления событиями на его потомках."
    },
    {
      "question": "Что такое JSON?",
      "answer": "JSON (JavaScript Object Notation) — это формат обмена данными, основанный на синтаксисе объектов JavaScript."
    },
    {
      "question": "Как клонировать объект в JavaScript?",
      "answer": "Можно использовать Object.assign({}, obj) или оператор распространения {...obj} для поверхностного клонирования."
    },
    {
      "question": "Что такое NaN?",
      "answer": "NaN (Not-a-Number) — это специальное значение, обозначающее, что результат операции не является числом."
    },
    {
      "question": "Как проверить, что значение является массивом?",
      "answer": "Используя Array.isArray(value)."
    },
    {
      "question": "Что делает метод bind()?",
      "answer": "Метод bind() создаёт новую функцию с привязанным контекстом 'this' и, при необходимости, с предустановленными аргументами."
    },
    {
      "question": "Что такое оператор spread?",
      "answer": "Оператор spread (...) позволяет разворачивать элементы массива или свойства объекта в местах, где ожидается множество элементов или аргументов."
    },
    {
      "question": "Что такое оператор rest?",
      "answer": "Оператор rest (...) собирает оставшиеся элементы в массив. Используется в параметрах функций для сбора всех оставшихся аргументов."
    },
    {
      "question": "Что такое шаблонные строки?",
      "answer": "Шаблонные строки — это строки, заключённые в обратные кавычки (`), позволяющие встраивать выражения с помощью ${expression}."
    },
    {
      "question": "Как работает оператор typeof?",
      "answer": "Оператор typeof возвращает строку, указывающую тип необъявленного или объявленного значения."
    },
    {
      "question": "Что такое объект arguments?",
      "answer": "arguments — это псевдомассив, содержащий все аргументы, переданные в функцию."
    },
    {
      "question": "Как работает метод setTimeout?",
      "answer": "setTimeout устанавливает таймер, который выполняет функцию или выражение через определённое количество миллисекунд."
    },
    {
      "question": "Что такое мемоизация?",
      "answer": "Мемоизация — это техника оптимизации, при которой результаты функций кэшируются для предотвращения повторных вычислений."
    },
    {
      "question": "Что такое callback-функция?",
      "answer": "Callback-функция — это функция, переданная в другую функцию в качестве аргумента и вызываемая после завершения операции."
    },
    {
      "question": "Что такое строгий режим ('use strict')?",
      "answer": "Строгий режим — это способ включения строгого контекста выполнения, который предотвращает использование некоторых небезопасных конструкций."
    },
    {
      "question": "Как работает метод map()?",
      "answer": "Метод map() создаёт новый массив, содержащий результаты вызова указанной функции для каждого элемента массива."
    }
  ],
  "React": [
    {
      "question": "Что такое React?",
      "answer": "React — это библиотека JavaScript для создания пользовательских интерфейсов, разработанная Facebook."
    },
      {
        "question": "Что такое JSX?",
        "answer": "JSX — это расширение синтаксиса JavaScript, позволяющее писать HTML-подобный код внутри JavaScript. Он компилируется в вызовы React.createElement()."
      },
      {
        "question": "Что такое компонент в React?",
        "answer": "Компонент — это независимый и переиспользуемый блок кода, который описывает часть интерфейса. Может быть функциональным или классовым."
      },
      {
        "question": "В чём разница между функциональными и классовыми компонентами?",
        "answer": "Функциональные компоненты — это простые функции, классовые — это классы, расширяющие React.Component и имеющие доступ к методам жизненного цикла."
      },
      {
        "question": "Что такое props?",
        "answer": "Props (свойства) — это объект, передаваемый компоненту от родителя. Используется для передачи данных и параметров."
      },
      {
        "question": "Что такое state в React?",
        "answer": "State — это объект, который хранит изменяемые данные компонента. Изменение state вызывает повторный рендер компонента."
      },
      {
        "question": "Как обновить state в React?",
        "answer": "В функциональных компонентах с помощью useState. В классовых — с помощью this.setState()."
      },
      {
        "question": "Что такое useEffect?",
        "answer": "useEffect — это хук, который позволяет выполнять побочные эффекты (fetch, подписки, таймеры) в функциональных компонентах."
      },
      {
        "question": "Когда вызывается useEffect?",
        "answer": "Он вызывается после рендера. Зависимости в массиве позволяют контролировать, при каких изменениях useEffect должен быть вызван повторно."
      },
      {
        "question": "Что такое виртуальный DOM?",
        "answer": "Виртуальный DOM — это легковесная копия реального DOM. React сравнивает старый и новый виртуальные DOM и применяет минимальные изменения к реальному DOM."
      },
      {
        "question": "Как работает ключ (key) в списках React?",
        "answer": "Key помогает React определить, какие элементы изменились, добавились или удалились. Это должно быть уникальное значение для каждого элемента."
      },
      {
        "question": "Что такое lifting state up?",
        "answer": "Это техника, при которой состояние поднимается до ближайшего общего родителя, чтобы несколько компонентов могли им делиться."
      },
      {
        "question": "Что такое порталы в React?",
        "answer": "Порталы позволяют рендерить дочерние элементы в DOM-узел, находящийся вне иерархии родительского компонента."
      },
      {
        "question": "Что такое HOC (Higher Order Component)?",
        "answer": "HOC — это функция, которая принимает компонент и возвращает новый компонент с дополнительной логикой или данными."
      },
      {
        "question": "Что такое context в React?",
        "answer": "Context предоставляет способ передавать данные через дерево компонентов без необходимости передавать props на каждом уровне."
      },
      {
        "question": "Что делает useContext?",
        "answer": "useContext позволяет подписаться на значение контекста в функциональном компоненте."
      },
      {
        "question": "Что такое ref?",
        "answer": "Ref используется для получения доступа к DOM-элементам или React-компонентам напрямую."
      },
      {
        "question": "Что такое controlled и uncontrolled компоненты?",
        "answer": "Controlled компоненты управляются React через state. Uncontrolled — через DOM напрямую, например, через ref."
      },
      {
        "question": "Зачем нужен useRef?",
        "answer": "useRef позволяет сохранять мутируемое значение, которое не вызывает повторный рендер при изменении."
      },
      {
        "question": "Можно ли использовать setState асинхронно?",
        "answer": "Да, setState работает асинхронно, и его результат нельзя получить сразу после вызова."
      },
      {
        "question": "Как работает React.memo?",
        "answer": "React.memo — это HOC, который предотвращает повторный рендер функционального компонента, если props не изменились."
      },
      {
        "question": "Что делает useCallback?",
        "answer": "useCallback возвращает мемоизированную версию функции, которая сохраняется между рендерами, если зависимости не изменились."
      },
      {
        "question": "Что делает useMemo?",
        "answer": "useMemo кэширует результат функции и пересчитывает его только при изменении зависимостей."
      },
      {
        "question": "Что делает StrictMode?",
        "answer": "StrictMode активирует дополнительные проверки и предупреждения для дочерних компонентов, помогает выявлять потенциальные проблемы."
      },
      {
        "question": "Как обрабатывать формы в React?",
        "answer": "Используя state для хранения значений полей и обработчики событий для обновления state при изменении значений."
      },
      {
        "question": "Можно ли использовать async/await в useEffect?",
        "answer": "Да, но сам useEffect не должен быть async. Вместо этого создаётся async-функция внутри и вызывается оттуда."
      },
      {
        "question": "Что такое error boundaries?",
        "answer": "Это классовые компоненты, которые перехватывают ошибки рендеринга в дочерних компонентах и отображают запасной UI."
      },
      {
        "question": "Можно ли использовать хуки в классовых компонентах?",
        "answer": "Нет. Хуки работают только в функциональных компонентах."
      },
      {
        "question": "Можно ли использовать несколько хуков useEffect?",
        "answer": "Да, это хороший способ разделять логику побочных эффектов по смыслу."
      },
      {
        "question": "Что делает useLayoutEffect?",
        "answer": "useLayoutEffect работает так же, как useEffect, но вызывается синхронно после всех изменений DOM, до отрисовки браузером."
      }
    ]
    
  }

  